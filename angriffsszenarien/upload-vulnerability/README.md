# file upload vulnerabilities — web shells through the front door

### payloads

{% embed url="https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php" %}

or simple web shell: `<?php echo system($_GET["cmd"]); ?>`

* directory scanning: find upload folders/assets/file storage
* source code review of upload scripts

### overwriting existing files

file uploads must check for existing files to prevent overwrites.

common protections:
* automatic renaming (random values, timestamps)
* filename conflict detection with user notification

## filtering and defense mechanisms

file validation methods you'll encounter:

**extension validation**
blacklist/whitelist file extensions like `.php`, `.php3`, `.py`
defines what's allowed (whitelist) or what's blocked (blacklist)

**file type filtering**
similar to extension validation:

- **MIME validation** - checks `Content-Type` header in HTTP request
  format: `<type>/<subtype>` like `image/png`
  easily bypassed since it only checks the declared type, not actual content

- **magic number/file signature validation** - checks first bytes of file
  each file type has unique byte signatures
  comprehensive list: https://en.wikipedia.org/wiki/List_of_file_signatures

**file size filtering**
prevents large uploads to protect server resources
can block payloads if limits are too restrictive
example: PHP reverse shell (5.4 KB) blocked if limit is 2 KB

**filename validation**
filenames should be unique on server (random component or error on conflicts)
must check for "malicious characters" (null bytes, slashes, control characters, unicode)
well-managed systems usually change original filename - uploaded shells may need to be located

**content filtering**
some systems check complete file content to detect spoofing of extensions, MIME types, and magic numbers

single filters are never perfect - usually multiple combined (client and server-side)
frameworks and languages bring their own filter methods that can enable specific exploits (null-byte injection in old PHP versions or PHP code in EXIF data)



## Filterung & Abwehrmaßnahmen

Zur Prüfung von Dateien können u.a. folgende Maßnahmen implementiert sein:

* **Validierung der Dateierweiterung (Extension Validation)**\
  Black - und/oder Whitelisting von Erweiterungen  wie php, php3, py, ...\
  Dabei kann u.a. definiert werden was erlaubt ist und alles andere wird abgelehnt oder umgekehrt\
  &#x20;
* **Filterung des Dateityps**\
  Ähnlich wie Extension Validation, hier gibt es u.a. die Methoden:\
  \
  \- MIME validation (**M**ultipurpose **I**nternet **M**ail **E**xtension), früher für Anhänge bei Mails verwendet, wird es heute auch beim Datentransfer über HTTP(s) verwendet. Der Datentyp wird im Request-Header unter _Content-Type_ definiert. Der Aufbau ist _\<typ>/\<subtyp>_, bspw. _image/png._\
  Die Korrektheit kann Client- sowie Serverseitig gepüft werden, allerdings schnell zu umgehen, da wirklich nur Dateierweiterung geprüft wird.\
  &#x20;\
  \- Magic Number/ File signature validation: Hier werden die ersten bytes einer Datei geprüft. Durch diese kann der Dateityp identifiziert werden. Die Länge bzw. Anzahl der Bytes unterscheidet sich nach Datei. Eine umfassende Liste ist verfügbar unter: [https://en.wikipedia.org/wiki/List\_of\_file\_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures).\
  &#x20;
* **Filterung der Dateilänge**\
  Filter verhindern das Hochladen sehr großer Dateien, um Serverressourcen zu schützen.\
  Kann Uploads beeinflussen, wenn nur sehr kleine Dateien erlaubt sind. Beispiel: PHP-Reverse-Shell (5,4 KB) könnte blockiert werden, wenn das Limit z. B. bei 2 KB liegt. In diesem Fall muss eine kleinere Datei verwendet werden.\
  &#x20;
* **Filterung des Dateinamens (**&#x44;ateinamen-Sanitization und -Kollisionsprüfung)\
  Dateinamen sollten auf dem Server eindeutig sein (z. B. Zufallskomponente oder Fehlerausgabe bei Namenskonflikt).\
  Zusätzlich müssen Dateinamen auf "schädliche Zeichen" geprüft werden (z. B. Null-Bytes, Slashes, Steuerzeichen, Unicode).\
  In gut verwalteten Systemen wird der ursprüngliche Dateiname meist verändert – Uploaded Shells müssen ggf. gesucht werden.\
  &#x20;
* **Filterung des Dateiinhalts**\
  Manche Systeme prüfen den kompletten Dateiinhalt, um Spoofing von Dateierweiterung, MIME-Type und Magic Number zu erkennen und zu verhindern.\
  &#x20;

Einzelne Filter sind nie perfekt – meist werden mehrere kombiniert (client- und serverseitig).\
Frameworks und Programmiersprachen bringen eigene Filtermethoden mit, die spezifische Exploits ermöglichen können (z. B. Null-Byte-Injection in alten PHP-Versionen oder PHP-Code in EXIF-Daten von Bildern)\
&#x20;

### Client-Seitig

Bypassing clientseitiger Upload-Filter

* **JavaScript deaktivieren**\
  Durch das Deaktivieren von JavaScript im Browser können viele clientseitige Filtermechanismen vollständig umgangen werden. Funktioniert, sofern die Website auch ohne JavaScript noch grundlegend bedienbar ist.\
  &#x20;
* **Manipulation der geladenen Seite**\
  Mithilfe von Tools wie BurpSuite kann die geladene Webseite abgefangen werden, bevor sie im Browser ausgeführt wird. Dabei kann der JavaScript-Upload-Filter entfernt oder verändert werden, sodass die Filterung nicht mehr greift. \
  Bei Burpsuite Intercept muss .js unter Proxy Settings "**Request Interception Rules**" als Ausnahme (Does not match) entfernt werden und die Response kann nach der Anfrage über "**Do Intercept**" -> "**Response to this request**" verändert werden.\
  &#x20;
* **Manipulation des Uploads nach Annahme**\
  Anstatt die Seite selbst zu verändern, kann der Dateiupload nach der Annahme durch die clientseitige Prüfung abgefangen und verändert werden. So lässt sich eine manipulierte Datei hochladen, obwohl die ursprüngliche Prüfung bestanden wurde.\
  &#x20;
* **Direkter Upload an den Server**\
  Dateien können direkt an den Upload-Endpoint geschickt werden, z. B. mit Tools wie curl. Dadurch wird der Web-Frontend-Filter komplett umgangen.\
  Der Upload kann erfolgen durch bspw: \
  `curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>`



Zuvor sollten erfolgreiche Uploads abgefangen werden (z. B. mit BurpSuite oder Browser-Konsole), um die benötigten Parameter für den direkten Request zu ermitteln.\
&#x20;

### Server-Seitig

Gegen **serverseitiges Extension-Filtering** sollte alles aus [php-upload-bypass.md](php-upload-bypass.md "mention") getestet werden.

Magic Numbers der Datei können mit hexedit \<file> geändert werden. Dabei kann das zu Ersetzende vorher als Platzhalter eingefügt werden. Bei 4 Bytes bspw. AAAA oder XXXX und das dann mit hexedit ersetzen. Die Liste an möglichen Magic Numbers/File Extensions ist weiter oben unter **Filterung des Dateityps (Wikipedia)** verlinkt. Danach das erfolgreiche Ändern mit file \<file> prüfen.





