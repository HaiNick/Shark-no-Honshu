# Unsicherer Datei-Upload

### Ressourcen

{% embed url="https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php" %}

Oder mit einfacher Webshell: `<?php echo system($_GET["cmd"]); ?>`

* Directory-Scanning : Identifikation von Upload-Ordnern/Assets/File-Storage
* Untersuchung des Quellcodes im Uploadscript

### Überschreiben existierender Dateien

* Datei-Uploads müssen geprüft werden, um das Überschreiben bestehender Dateien zu verhindern.
* Übliche Schutzmechanismen:
  * Automatisches Umbenennen hochgeladener Dateien (z. B. Zufallswert, Zeitstempel).
  * Prüfung auf vorhandene Dateinamen und Rückmeldung an den Benutzer bei Konflikten.



## Filterung & Abwehrmaßnahmen

Zur Prüfung von Dateien können u.a. folgende Maßnahmen implementiert sein:

* **Validierung der Dateierweiterung (Extension Validation)**\
  Black - und/oder Whitelisting von Erweiterungen  wie php, php3, py, ...\
  Dabei kann u.a. definiert werden was erlaubt ist und alles andere wird abgelehnt oder umgekehrt\
  &#x20;
* **Filterung des Dateityps**\
  Ähnlich wie Extension Validation, hier gibt es u.a. die Methoden:\
  \
  \- MIME validation (**M**ultipurpose **I**nternet **M**ail **E**xtension), früher für Anhänge bei Mails verwendet, wird es heute auch beim Datentransfer über HTTP(s) verwendet. Der Datentyp wird im Request-Header unter _Content-Type_ definiert. Der Aufbau ist _\<typ>/\<subtyp>_, bspw. _image/png._\
  Die Korrektheit kann Client- sowie Serverseitig gepüft werden, allerdings schnell zu umgehen, da wirklich nur Dateierweiterung geprüft wird.\
  &#x20;\
  \- Magic Number/ File signature validation: Hier werden die ersten bytes einer Datei geprüft. Durch diese kann der Dateityp identifiziert werden. Die Länge bzw. Anzahl der Bytes unterscheidet sich nach Datei. Eine umfassende Liste ist verfügbar unter: [https://en.wikipedia.org/wiki/List\_of\_file\_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures).\
  &#x20;
* **Filterung der Dateilänge**\
  Filter verhindern das Hochladen sehr großer Dateien, um Serverressourcen zu schützen.\
  Kann Uploads beeinflussen, wenn nur sehr kleine Dateien erlaubt sind. Beispiel: PHP-Reverse-Shell (5,4 KB) könnte blockiert werden, wenn das Limit z. B. bei 2 KB liegt. In diesem Fall muss eine kleinere Datei verwendet werden.\
  &#x20;
* **Filterung des Dateinamens (**&#x44;ateinamen-Sanitization und -Kollisionsprüfung)\
  Dateinamen sollten auf dem Server eindeutig sein (z. B. Zufallskomponente oder Fehlerausgabe bei Namenskonflikt).\
  Zusätzlich müssen Dateinamen auf "schädliche Zeichen" geprüft werden (z. B. Null-Bytes, Slashes, Steuerzeichen, Unicode).\
  In gut verwalteten Systemen wird der ursprüngliche Dateiname meist verändert – Uploaded Shells müssen ggf. gesucht werden.\
  &#x20;
* **Filterung des Dateiinhalts**\
  Manche Systeme prüfen den kompletten Dateiinhalt, um Spoofing von Dateierweiterung, MIME-Type und Magic Number zu erkennen und zu verhindern.\
  &#x20;

Einzelne Filter sind nie perfekt – meist werden mehrere kombiniert (client- und serverseitig).\
Frameworks und Programmiersprachen bringen eigene Filtermethoden mit, die spezifische Exploits ermöglichen können (z. B. Null-Byte-Injection in alten PHP-Versionen oder PHP-Code in EXIF-Daten von Bildern)\
&#x20;

### Client-Seitig

Bypassing clientseitiger Upload-Filter

* **JavaScript deaktivieren**\
  Durch das Deaktivieren von JavaScript im Browser können viele clientseitige Filtermechanismen vollständig umgangen werden. Funktioniert, sofern die Website auch ohne JavaScript noch grundlegend bedienbar ist.\
  &#x20;
* **Manipulation der geladenen Seite**\
  Mithilfe von Tools wie BurpSuite kann die geladene Webseite abgefangen werden, bevor sie im Browser ausgeführt wird. Dabei kann der JavaScript-Upload-Filter entfernt oder verändert werden, sodass die Filterung nicht mehr greift. \
  Bei Burpsuite Intercept muss .js unter Proxy Settings "**Request Interception Rules**" als Ausnahme (Does not match) entfernt werden und die Response kann nach der Anfrage über "**Do Intercept**" -> "**Response to this request**" verändert werden.\
  &#x20;
* **Manipulation des Uploads nach Annahme**\
  Anstatt die Seite selbst zu verändern, kann der Dateiupload nach der Annahme durch die clientseitige Prüfung abgefangen und verändert werden. So lässt sich eine manipulierte Datei hochladen, obwohl die ursprüngliche Prüfung bestanden wurde.\
  &#x20;
* **Direkter Upload an den Server**\
  Dateien können direkt an den Upload-Endpoint geschickt werden, z. B. mit Tools wie curl. Dadurch wird der Web-Frontend-Filter komplett umgangen.\
  Der Upload kann erfolgen durch bspw: \
  `curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>`



Zuvor sollten erfolgreiche Uploads abgefangen werden (z. B. mit BurpSuite oder Browser-Konsole), um die benötigten Parameter für den direkten Request zu ermitteln.\
&#x20;

### Server-Seitig

Gegen **serverseitiges Extension-Filtering** sollte alles aus [php-upload-bypass.md](php-upload-bypass.md "mention") getestet werden.

Magic Numbers der Datei können mit hexedit \<file> geändert werden. Dabei kann das zu Ersetzende vorher als Platzhalter eingefügt werden. Bei 4 Bytes bspw. AAAA oder XXXX und das dann mit hexedit ersetzen. Die Liste an möglichen Magic Numbers/File Extensions ist weiter oben unter **Filterung des Dateityps (Wikipedia)** verlinkt. Danach das erfolgreiche Ändern mit file \<file> prüfen.





