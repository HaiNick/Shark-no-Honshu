# upload filter bypass strategies. make servers execute what they shouldn't.

| filter | bypass methods |
|--------|----------------|
| **client-side validation** | disable javascript, use burp/curl, modify dom |
| **extension check only** | double extensions: `shell.php.jpg`, alt extensions: `.php5/.phtml`, case variation: `.PhP`, trailing chars: `shell.php.` |
| **content-type validation** | manipulate `Content-Type` header: set to `image/jpeg` for php files |
| **magic number check** | prepend valid file header, use polyglot files, hide code in metadata |
| **extension + content-type** | combine: right extension + fake content-type, embed in allowed filetype |
| **strict server validation** | polyglot files, code in image metadata/exif, legitimate header + payload in comments |
| **file size limits** | compress payloads, use minimal shells, split upload into parts |
| **filename sanitization** | url encode special chars: `%2e %2f`, unicode chars, path traversal: `..%2f ..\\` |
| **outside webroot storage** | check if files accessible via direct paths, attempt path manipulation to public areas |
| **blacklist filters** | modify extensions: `.phpp .phtml`, creative mime types |
| **overwrite protection** | test special filenames: `.htaccess`, check if server validates names properly |

## quick test sequence

1. try direct upload of `.php` file
2. if blocked, try alternative extensions (`.php5`, `.phtml`, `.inc`)
3. if still blocked, fake content-type: `Content-Type: image/jpeg`
4. if still blocked, add image header + php code
5. if still blocked, try polyglot approach
6. if still blocked, try client-side bypasses

## operational notes

- filters are usually layered - bypass one at a time
- framework-specific exploits exist (null-byte in old php)
- [!] test in isolated environment first - some methods crash services
- always scan for uploaded files - names often get randomized

# TODO: test bypasses against modsecurity rules