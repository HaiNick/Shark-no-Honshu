# bypass strategies — because filters are meant to be broken

<table><thead><tr><th width="236">Filtermechanismus</th><th>Beschreibung</th><th>Mögliche Bypass-Strategien</th></tr></thead><tbody><tr><td><strong>Clientseitige Validierung</strong></td><td>Prüfung durch JavaScript oder HTML5 vor dem Upload</td><td>- JavaScript deaktivieren<br>- Upload direkt mit Tools wie <code>curl</code> oder <code>Burp Suite</code> durchführen<br>- HTML/JS-Code im Browser manipulieren</td></tr><tr><td><strong>Dateiendungsprüfung (</strong>Nur Extension-Check)</td><td>Reine Überprüfung der Dateiendung (z. B. <code>.jpg</code>, <code>.png</code>)</td><td>- Doppelte Erweiterungen verwenden: <code>shell.php.jpg</code><br>- Ungewöhnliche Erweiterungen nutzen: <code>.php5</code>, <code>.phtml</code><br>- Groß-/Kleinschreibung variieren: <code>.PhP</code>, <code>.pHp</code><br>- Null-Byte-Injektion: <code>shell.php%00.jpg</code><br>- Erweiterungen mit Leerzeichen oder Punkten: <code>shell.php.</code> , <code>shell.php...</code></td></tr><tr><td>Extension + Content-Type-Check</td><td>Kombination, aber evtl. ohne Magic Number</td><td><p>- Richtige Extension und gefakter Content-Type</p><p>- Code in erlaubtem Dateityp verstecken (z.B. EXIF in JPG)</p></td></tr><tr><td><strong>Content-Type-Validierung</strong></td><td>Prüfung des MIME-Typs der Datei (z. B. <code>image/jpeg</code>)</td><td>- MIME-Typ im HTTP-Request manipulieren: <code>Content-Type: image/jpeg</code> für eine <code>.php</code>-Datei<br>- Tools wie <code>Burp Suite</code> oder <code>curl</code> verwenden, um den Header zu ändern</td></tr><tr><td><strong>Magic Number-Prüfung</strong></td><td>Überprüfung der ersten Bytes der Datei zur Identifikation des Dateityps</td><td>- Datei mit gültiger Magic Number versehen (z. B. JPEG-Header) und Schadcode anhängen<br>- Validen Header beibehalten und Payload in Metadaten (z. B. EXIF) einbetten</td></tr><tr><td>Serverseitige strenge Validierung</td><td>Extension, Content-Type und Magic Number werden geprüft</td><td><p></p><p>- Polyglot-Dateien (z.B. Bild + PHP)</p><p>- Legitimer Header, Payload im Kommentarfeld (z.B. EXIF)</p></td></tr><tr><td><strong>Dateigrößenbeschränkung</strong></td><td>Begrenzung der maximalen Dateigröße (z. B. 2 KB)</td><td>- Komprimierte Payloads verwenden<br>- Minimalistische Shells nutzen (z. B. 1 KB PHP-Shell)<br>- Payload in mehreren Teilen hochladen und serverseitig zusammenführen</td></tr><tr><td><strong>Dateinamenprüfung</strong></td><td>Überprüfung auf unerlaubte Zeichen oder Pfadangaben im Dateinamen</td><td>- URL-kodierte Zeichen verwenden: <code>%2e</code>, <code>%2f</code><br>- Unicode-Zeichen einsetzen<br>- Pfadangaben verschleiern: <code>..%2f</code>, <code>..\\</code></td></tr><tr><td><strong>Speicherort außerhalb des Webroots</strong></td><td>Dateien werden außerhalb des öffentlich zugänglichen Verzeichnisses gespeichert</td><td>- Überprüfen, ob Dateien dennoch über direkte Pfadangaben erreichbar sind<br>- Versuchen, durch Pfadmanipulation in öffentlich zugängliche Bereiche zu schreiben</td></tr><tr><td>Blacklist-Filter</td><td>Prüft auf bestimmte verbotene Typen/Wörter</td><td>- Extension leicht verändern (<code>.phpp</code>, <code>.phtml</code>)<br>- MIME-Type kreativ wählen</td></tr><tr><td><strong>Schutz gegen Dateiüberschreibung</strong></td><td>Verhindert das Überschreiben bestehender Dateien</td><td>- Überprüfen, ob durch spezielle Dateinamen (z. B. <code>.htaccess</code>) kritische Dateien überschrieben werden können<br>- Testen, ob der Server Dateinamen nicht ausreichend prüft und so Überschreibungen möglich sind</td></tr></tbody></table>
