# Rootkit

Ein Rootkit ist eine Art von Schadsoftware, die entwickelt wurde, um sich tief in einem Computersystem zu verbergen und unbemerkten Zugriff zu ermöglichen.

Die grundlegenden Funktionsweisen und Merkmale eines Rootkits sind:

1. **Verstecken**: Ein Hauptziel von Rootkits ist es, sich selbst und andere Schadsoftware zu verbergen. Dies kann durch Manipulation von Systemdateien, -prozessen und -diensten erfolgen. Zum Beispiel können sie Dateien oder Prozesse unsichtbar machen, sodass sie vom Benutzer oder Antivirenprogrammen nicht entdeckt werden können.
2. **Erhöhte Berechtigungen**: Rootkits verschaffen sich oft höhere Berechtigungen auf einem System (z.B. Root-Zugriff auf Unix/Linux-Systemen oder Administratorrechte auf Windows-Systemen), um tiefere Eingriffe vorzunehmen und ihre Aktivitäten besser zu verstecken.
3. **Manipulation von Systemaufrufen**: Sie können Systemaufrufe (System Calls) abfangen und ändern, um ihre Anwesenheit zu verbergen. Zum Beispiel könnten sie den Systemaufruf, der eine Liste aller laufenden Prozesse zurückgibt, so verändern, dass sie selbst nicht in der Liste erscheinen.
4. **Persistenz**: Viele Rootkits sind darauf ausgelegt, nach einem Systemneustart weiterhin aktiv zu sein. Dies kann durch Änderungen an Boot-Sektoren oder Kerneltreibern erreicht werden.
5. **Schadfunktionalität**: Abhängig vom Zweck des Rootkits können sie verschiedene schädliche Aktivitäten ausführen, z.B.:
   * **Keylogging**: Aufzeichnen von Tastenanschlägen, um Passwörter und andere vertrauliche Informationen zu stehlen.
   * **Backdoor**: Erstellen von versteckten Hintertüren, um Angreifern den Fernzugriff zu ermöglichen.
   * **Datendiebstahl**: Stehlen von sensiblen Daten.
   * **DDoS**: Nutzung des infizierten Systems für Distributed Denial-of-Service-Angriffe.
6. **Infektionsmethoden**: Rootkits können durch verschiedene Methoden auf ein System gelangen, z.B. durch Exploits, infizierte Softwaredownloads, Phishing-Angriffe oder andere Schadsoftware, die das Rootkit nachlädt.

#### Arten von Rootkits

* **User-Mode Rootkits**: Diese arbeiten auf der Ebene des Benutzerbereichs des Betriebssystems und manipulieren Anwendungen und API-Aufrufe.
* **Kernel-Mode Rootkits**: Diese operieren auf der Kernel-Ebene und haben tiefere Systemkontrolle, wodurch sie schwerer zu entdecken und zu entfernen sind.
* **Bootkits**: Diese infizieren den Bootloader oder den Master Boot Record (MBR) und laden sich beim Systemstart, noch bevor das Betriebssystem vollständig hochgefahren ist.
* **Firmware-Rootkits**: Diese infizieren die Firmware des Systems, wie z.B. BIOS oder UEFI, und sind daher extrem schwer zu entdecken und zu entfernen.

#### Schutz und Erkennung

* **Regelmäßige Updates**: Halten Sie Betriebssysteme und Software auf dem neuesten Stand, um bekannte Sicherheitslücken zu schließen.
* **Antivirus- und Anti-Malware-Programme**: Nutzen Sie Sicherheitssoftware, die speziell auf die Erkennung von Rootkits ausgelegt ist.
* **Sicherheitsrichtlinien**: Implementieren Sie strenge Sicherheitsrichtlinien und Zugriffsrechte, um die Installation von Rootkits zu erschweren.
* **Systemüberwachung**: Überwachen Sie ungewöhnliche Systemaktivitäten, die auf die Präsenz eines Rootkits hindeuten könnten.
* **Forensische Analyse**: Im Verdachtsfall kann eine forensische Analyse des Systems durchgeführt werden, um versteckte Rootkits zu identifizieren und zu entfernen.

#### Beispiele



{% code title="C/C++ (Proc verstecken)" %}
```clike
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/sched.h>

static struct proc_dir_entry *proc_entry;

static int my_proc_show(struct seq_file *m, void *v) {
    struct task_struct *task;

    for_each_process(task) {
        if (strcmp(task->comm, "hidden_process") != 0) {
            seq_printf(m, "%s [%d]\n", task->comm, task->pid);
        }
    }
    return 0;
}

static int my_proc_open(struct inode *inode, struct file *file) {
    return single_open(file, my_proc_show, NULL);
}

static const struct file_operations my_proc_fops = {
    .owner = THIS_MODULE,
    .open = my_proc_open,
    .read = seq_read,
    .release = single_release,
};

static int __init my_module_init(void) {
    proc_entry = proc_create("my_proc", 0, NULL, &my_proc_fops);
    if (!proc_entry) {
        return -ENOMEM;
    }
    return 0;
}

static void __exit my_module_exit(void) {
    proc_remove(proc_entry);
}

module_init(my_module_init);
module_exit(my_module_exit);

MODULE_LICENSE("GPL");

```
{% endcode %}

{% code title="Assembler (MBR)" %}
```armasm
[BITS 16]
[ORG 0x7C00]

start:
    MOV AH, 0x0E
    MOV AL, 'H'
    INT 0x10
    MOV AL, 'e'
    INT 0x10
    MOV AL, 'l'
    INT 0x10
    MOV AL, 'l'
    INT 0x10
    MOV AL, 'o'
    INT 0x10
    MOV AL, ' '
    INT 0x10
    MOV AL, 'W'
    INT 0x10
    MOV AL, 'o'
    INT 0x10
    MOV AL, 'r'
    INT 0x10
    MOV AL, 'l'
    INT 0x10
    MOV AL, 'd'
    INT 0x10

    HLT

TIMES 510 - ($ - $$) DB 0
DW 0xAA55

```
{% endcode %}

{% code title="python (Datei verstecken)" %}
```python
import os

def hide_file(filename):
    hidden_filename = f".{filename}"
    os.rename(filename, hidden_filename)
    print(f"File {filename} has been hidden as {hidden_filename}")

# Usage example
hide_file("test.txt")

```
{% endcode %}

{% code title="shell (Datei verstecken)" %}
```sh
#!/bin/bash

hide_file() {
    local filename=$1
    local hidden_filename=".$filename"
    mv "$filename" "$hidden_filename"
    echo "File $filename has been hidden as $hidden_filename"
}

# Usage example
hide_file "test.txt"
```
{% endcode %}

